#+TITLE: Worgle
* What is Worgle?
Hello, fellow human. I'm glad you could stop by.

This is a document written
in Org markup, talking about a thing I'm building called Worgle. The name
*Worgle* is derived from what it is: a Worg Tangler. =Worg= is the name of this
project. It too gets its name from what it is: a WEB + Org project.
Org is the very decent markup language from org-mode.
WEB is
the name of the first literate programming tool ever created by Donald Knuth.
In literate programming,
one writes language and code together in a markup language, which can
then be parsed two ways. The *weaver* parses the markup to produce a
human readable document, usually a (La)TeX or HTML file. The *tangler*
parses the markup and produces computer code that can be read by a computer
to run or compile the program.

In other words, Worgle is a literate programming tangler used to convert
org-like markup into (primarily) code.

Worgle itself is a literate program, so what tangles the worgle code? Orgle
does! Orgle is a program written in C without literate programming. It is
designed to be just enough of a program to bootstrap Worgle. Worgle will
then be used as the tangler for the rest of Worg.

Worgle will initially start out as a literate program of Orgle. In fact,
this document will initially start out as an outline for the Orgle program.
The Orgle program will be considered done when it is able to produce a similar
program by parsing this Worgle document. After that is done, more work will
be put into Worgle to make it more suitable for managing larger projects
written in C.

Following me so far? No? Yes? Great, let's get started.
* Top-level files
Like Orgle, Worgle is self contained inside of a single C file.
For the time being, this is suitable enough. The current scope of Worgle is
to be a self-contained standalone CLI application.

#+NAME: worgle-top
#+BEGIN_SRC c :tangle worgle.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#ifndef wORGLITE
#include <sqlite3.h>
#endif
#include "parg.h"
#include "worgle.h"
#include "worgle_private.h"
#ifndef WORGLITE
#include "db.h"
#endif

<<global_variables>>
<<enums>>
<<static_function_declarations>>
<<functions>>

int main(int argc, char *argv[])
{
    <<local_variables>>
    <<initialization>>
    <<loading>>
    <<parsing>>
    <<generation>>
    <<mapping>>
    <<database>>
    <<cleanup>>
}

#+END_SRC

In more recent developments of Worgle, a corresponding header file will be
generated with the C file. This is needed so that other C files can be
generated.

#+NAME: worgle-header
#+BEGIN_SRC c :tangle worgle.h
#ifndef WORGLE_H
#define WORGLE_H
<<typedefs>>
<<function_declarations>>
#endif
#+END_SRC

Private data (for things like structs), is stored in a header file called
=worgle_private.h=.

#+NAME: worgle-private-header
#+BEGIN_SRC c :tangle worgle_private.h
#ifndef WORGLE_PRIVATE_H
<<structs>>
#define WORGLE_PRIVATE_H
#endif
#+END_SRC
* An Outline of What Worgle does
This aims to show a broad overview of how Orgle (and Worgle) will work
essentially. Orgle is a bootstrap program written in C, used to generate
C code for Worgle (this program here). At the highest level, the two
programs share the same basic program structure.
** Initialization
*** Initialize worgle data

Worgle is initialized before stuff is loaded.

#+NAME: local_variables
#+BEGIN_SRC c
worgle_d worg;
#+END_SRC

#+NAME: initialization
#+BEGIN_SRC c
worgle_init(&worg);
#+END_SRC
*** Get and set filename

The file name is currently aqcuired from the command line, so the
program must check and make sure that there are the right number of
arguments. If there isn't, return an error.

#+NAME: local_variables
#+BEGIN_SRC c
char *filename;
#+END_SRC

#+NAME: initialization
#+BEGIN_SRC c
filename = NULL;
if(argc < 2) {
    fprintf(stderr, "Usage: %s filename.org\n", argv[0]);
    return 1;
}
<<parse_cli_args>>
<<check_filename>>
#+END_SRC

Check the filename.
If the filename is not set inside by the command line, return an error,

#+NAME:check_filename
#+BEGIN_SRC c
if(filename == NULL) {
    fprintf(stderr, "No filename specified\n");
    return 1;
}
#+END_SRC

*** Initialize return codes

The main return code determines the overall state of the program.

#+NAME: local_variables
#+BEGIN_SRC c
int rc;
#+END_SRC

By default, it is set to be okay, which is 0 on POSIX systems.

#+NAME: initialization
#+BEGIN_SRC c
rc = 0;
#+END_SRC

** Load file into memory
The first thing the program will do is load the file.

While most parsers tend to parse things on a line by line basis via
a file stream, this parser will load the entire file into memory. This
is done due to the textual nature of the program. It is much easier to
simply allocate everything in one big block and reference chunks, then to
allocate smaller chunks as you go.
*** Loadfile function
#+NAME: loading
#+BEGIN_SRC c
for(i = 0; i < worg.nbuffers; i++) {
    rc = loadfile(&worg, i);
    if(!rc) goto cleanup;
}
#+END_SRC
A file is loaded into a textbuffer via the function =loadfile=. In the
worg startup sequence, the buffer list has been preallocated with the
filename after parsing the command line arguments (see <<append_filename>>).
It is in this stage that the memory block is allocated and the file loaded into
it. The file will be allocated and loaded into the file located in index
position =file=.

On success, the function will return TRUE (1). On failure, FALSE (0).
#+NAME: static_function_declarations
#+BEGIN_SRC c
static int loadfile(worgle_d *worg, int file);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int loadfile(worgle_d *worg, int file)
{
    <<loadfile_localvars>>
    <<loadfile>>
    return 1;
}
#+END_SRC
*** Open file
File is loaded into a local file handle =fp=.

#+NAME: loadfile_localvars
#+BEGIN_SRC c
FILE *fp;
char *filename;
worgle_textbuf *txt;
#+END_SRC

#+NAME: loadfile
#+BEGIN_SRC c
txt = &worg->buffers[file];
filename = txt->filename.str;
fp = fopen(filename, "r");

if(fp == NULL) {
    fprintf(stderr, "Could not find file %s\n", filename);
    return 1;
}
#+END_SRC
*** Get file size
The size is acquired by going to the end of the file and getting the current
file position.

#+NAME: loadfile_localvars
#+BEGIN_SRC c
size_t size;
#+END_SRC

#+NAME: loadfile
#+BEGIN_SRC c
fseek(fp, 0, SEEK_END);
size = ftell(fp);
#+END_SRC
*** Allocate memory, read, and close
Memory is allocated in a local buffer variable via =calloc=. The buffer
is then stored inside of the worg struct.

#+NAME: loadfile_localvars
#+BEGIN_SRC c
char *buf;
#+END_SRC

#+NAME: loadfile
#+BEGIN_SRC c
buf = calloc(1, size);
worgle_textbuf_init(&worg->buffers[file], buf, size);
#+END_SRC

The file is rewound back to the beginning and then read into the buffer. The
file is no longer needed at this point, so it is closed.

#+NAME: loadfile
#+BEGIN_SRC c
fseek(fp, 0, SEEK_SET);
fread(buf, size, 1, fp);
fclose(fp);
#+END_SRC
** Parsing
*** Parsing Modes
The parser is implemented as a relatively simple state
machine, whose behavior shifts between parsing org-mode
markup (=MODE_ORG=), and code blocks (=MODE_BEGINCODE= and
=MODE_CODE=). The state machine makes a distinction between
the start of a new code block (=MODE_BEGINCODE=), which
provides information like the name of the code block and
optionally the name of the file to tangle to, and the code
block itself (=MODE_CODE=).
#+NAME: enums
#+BEGIN_SRC c
enum {
<<parse_modes>>
};
#+END_SRC
**** MODE_ORG
#+NAME:parse_modes
#+BEGIN_SRC c
MODE_ORG,
#+END_SRC
***** Org Parse Top
When the parser state is set to be in =MODE_ORG=, this is
what happens.
#+NAME: parse_mode_org
#+BEGIN_SRC c
#ifndef WORGLITE
if (generate_db) {
    <<parse_headers>>
}
#endif
<<find_next_named_block>>
#+END_SRC
***** Finding the next named block
When the parser is in =MODE_ORG=, it mostly searching for
the start of the next named block. When it finds a match,
it extracts the name, gets ready to begin the a new block,
and changes the mode =MODE_BEGINCODE=.

A common hard-to-find error happens when a colon is
forgotten in the =NAME= tag. A special check will occur
here to make sure that colon isn't forgotten.
#+NAME: find_next_named_block
#+BEGIN_SRC c
if(read >= 7) {
    if(!strncmp(line, "#+NAME", 6)) {
        if(line[6] != ':') {
            fprintf(stderr,
                    "line %lu: expected ':'\n",
                    worg->linum);
            rc = 1;
            break;
        }
        mode = MODE_BEGINCODE;
        parse_name(line, read, &str);
        worgle_begin_block(worg, &str);
    }
}
#+END_SRC
***** Extracting information from #+NAME

Name extraction of the current line is done with a function called =parse_name=.

#+NAME: static_function_declarations
#+BEGIN_SRC c
static int parse_name(char *line, size_t len, worgle_string *str);
#+END_SRC

# TODO: words here

#+NAME: functions
#+BEGIN_SRC c
static int parse_name(char *line, size_t len, worgle_string *str)
{
    size_t n;
    size_t pos;
    int mode;

    line+=7;
    len-=7;
    /* *namelen = 0; */
    str->size = 0;
    str->str = NULL;
    if(len <= 0) return 1;
    pos = 0;
    mode = 0;
    for(n = 0; n < len; n++) {
        if(mode == 2) break;
        switch(mode) {
            case 0:
                if(line[n] == ' ') {

                } else {
                    str->str = &line[n];
                    str->size++;
                    pos++;
                    mode = 1;
                }
                break;
            case 1:
                if(line[n] == 0xa) {
                    mode = 2;
                    break;
                }
                pos++;
                str->size++;
                break;
            default:
                break;
        }
    }
    /* *namelen = pos; */
    return 1;
}
#+END_SRC
***** Beginning a new block

A new code block is started with the function =worgle_begin_block=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_begin_block(worgle_d *worg, worgle_string *name);
#+END_SRC

When a new block begins, the current block in Worgle is set to be
a value retrieved from the block dictionary.

#+NAME: functions
#+BEGIN_SRC c
void worgle_begin_block(worgle_d *worg, worgle_string *name)
{
    worg->curblock = worgle_hashmap_get(&worg->dict, name);
    <<worgle_block_set_id>>
}
#+END_SRC
***** DONE Parsing Header Information
CLOSED: [2019-09-12 Thu 07:10]
A valid header in org mode starts with one or more
as one or more asterisks, followed by a space.
Anything after this space is considered to be the name
of the header. The number of asterisks indicates the
header level.

If indeed the line is a header, both the header name
and level are appended to the currently opened org file.

A quick sanity check is done before the header is parsed
via =parse_header=.

#+NAME: parse_headers
#+BEGIN_SRC c
if (read >= 2) {
    parse_header(worg, line, read);
}
#+END_SRC

The actual parsing logic happens in the function
=parse_header=.

#+NAME: static_function_declarations
#+BEGIN_SRC c
#ifndef WORGLITE
static int parse_header(worgle_d *worg,
                        char *line,
                        size_t len);
#endif
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
#ifndef WORGLITE
static int parse_header(worgle_d *worg,
                        char *line,
                        size_t len)
{
    int mode;
    int rc;
    size_t s;
    char *header;
    worgle_string str;
    int lvl;
    mode = 0;

    if(line[0] != '*') return 0;

    rc = 0;
    worgle_string_init(&str);
    lvl = 1;
    for (s = 1; s < len; s++) {
        if (mode == 2) break;
        switch (mode) {
            case 0:
                if (line[s] == '*') {
                    lvl++;
                } else if (line[s] == ' '){
                    mode = 1;
                } else {
                    mode = 2;
                    rc = 0;
                }
                break;
            case 1:
                rc = 1;
                mode = 2;
                header = &line[s];
                str.str = header;
                str.size = len - s;
                str.size -= line[len - 1] == '\n';
                worgle_orgfile_append_header(worg,
                                             &str,
                                             lvl);
                break;
        }
    }
    return rc;
}
#endif
#+END_SRC
***** TODO Content Parsing
In between headers and codeblocks are things called
=content=. It is assumed to be text like this, but it can
also contain comments and commands that worgle doesn't
yet understand.

Content is similar to code in code blocks. While the parser
is just shifting through ORG code (that's not a header), it
will append lines to a buffer. When it reaches either a
code block or a new header, it will save that buffer as
a unit. For this reason, content parsing should happen last.

Appending content to the content block is simply a matter of
extending the size of the block (text is mapped to a
contiguous memory block).

When a content block is started, the block variable must be
reset. The circumstances for a starting a content block
happen: whenever a new header is found, or whenever content
is found immediately after a code block ends.

# ^^^ But how will worgle know this?
***** TODO Code Reference
Anytime a new code block begins, a reference to this new
block is stored in the data representation of the file. This
should happen when a new block begins. Probably in
=worgle_begin_block=.
**** MODE_BEGINCODE
#+NAME:parse_modes
#+BEGIN_SRC c
MODE_BEGINCODE,
#+END_SRC

A parser set to mode =MODE_BEGINCODE= is only interested in
finding the beginning block. If it doesn't, it returns a
syntax error. If it does, it goes on to extract a potential
new filename to tangle, which then gets appended to the
Worgle file list.

#+NAME: parse_mode_begincode
#+BEGIN_SRC c
if (read >= 11) {
    if(!strncmp (line, "#+BEGIN_SRC",11)) {
        <<begin_the_code>>
        if (parse_begin(line, read, &str) == 2) {
            worgle_append_file(worg, &str);
        }
        continue;
    } else {
        fwrite(line, read, 1, stderr);
        fprintf(stderr,
                "line %lu: Expected #+BEGIN_SRC\n",
                worg->linum);
        rc = 1;
        break;
    }
}
fprintf(stderr,
        "line %lu: Expected #+BEGIN_SRC\n",
        worg->linum);
rc = 1;
#+END_SRC
***** Extracting information from #+BEGIN_SRC

The begin source flag in org-mode can have a number of options,
but the only one we really care about for this tangler is
the ":tangle" option.

#+NAME: static_function_declarations
#+BEGIN_SRC c
static int parse_begin(char *line, size_t len, worgle_string *str);
#+END_SRC

The state machine begins right after the BEGIN_SRC declaration, which
is why the string is offset by 11.

The state machine for this parser is linear, and has 5 modes:

- mode 0: Skip whitespace after BEGIN_SRC
- mode 1: Find ":tangle" pattern
- mode 2: Ignore imediate whitespace after "tangle", and begin getting filename
- mode 3: Get filename size by reading up to the next space or line break
- mode 4: Don't do anything, wait for line to end.

#+NAME: functions
#+BEGIN_SRC c
static int parse_begin(char *line, size_t len, worgle_string *str)
{
    size_t n;
    int mode;
    int rc;

    line += 11;
    len -= 11;

    if(len <= 0) return 0;


    mode = 0;
    n = 0;
    rc = 1;
    str->str = NULL;
    str->size = 0;
    while(n < len) {
        switch(mode) {
            case 0: /* initial spaces after BEGIN_SRC */
                if(line[n] == ' ') {
                    n++;
                } else {
                    mode = 1;
                }
                break;
            case 1: /* look for :tangle */
                if(line[n] == ' ') {
                    mode = 0;
                    n++;
                } else {
                    if(line[n] == ':') {
                        if(!strncmp(line + n + 1, "tangle", 6)) {
                            n+=7;
                            mode = 2;
                            rc = 2;
                        }
                    }
                    n++;
                }
                break;
            case 2: /* save file name, spaces after tangle */
                if(line[n] != ' ') {
                    str->str = &line[n];
                    str->size++;
                    mode = 3;
                }
                n++;
                break;
            case 3: /* read up to next space or line break */
                if(line[n] == ' ' || line[n] == '\n') {
                    mode = 4;
                } else {
                    str->size++;
                }
                n++;
                break;
            case 4: /* countdown til end */
                n++;
                break;
        }
    }

    return rc;
}
#+END_SRC
***** Setting up code for a new read
When a new codeblock has indeed been found, the mode is switched to =MODE_CODE=,
and the =block_started= boolean flag gets set. In addition, the string used
to keep track of the new block is reset.
#+NAME: begin_the_code
#+BEGIN_SRC c
mode = MODE_CODE;
worg->block_started = 1;
worgle_string_reset(&worg->block);
#+END_SRC
***** Appending a new file
If a new file is found, the filename gets appended to the file list
via the function =worgle_append_file=.

#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_append_file(worgle_d *worg, worgle_string *filename);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_append_file(worgle_d *worg, worgle_string *filename)
{
    worgle_file *f;
    f = worgle_filelist_append(&worg->flist, filename, worg->curblock);
    <<worgle_file_set_id>>
}
#+END_SRC
**** MODE_CODE
#+NAME:parse_modes
#+BEGIN_SRC c
MODE_CODE
#+END_SRC

In =MODE_CODE=, actual code is parsed inside of the code
block. The parser will keep reading chunks of code until
one of two things happen: a code reference is found, or the
=END_SRC= command is found.

#+NAME: parse_mode_code
#+BEGIN_SRC c
if(read >= 9) {
    if(!strncmp(line, "#+END_SRC", 9)) {
        mode = MODE_ORG;
        worg->block_started = 0;
        worgle_append_string(worg);
        continue;
    }
}

if(check_for_reference(line, read, &str)) {
    worgle_append_string(worg);
    worgle_append_reference(worg, &str);
    worg->block_started = 1;
    worgle_string_reset(&worg->block);
    continue;
}

worg->block.size += read;

if(worg->block_started) {
    worg->block.str = line;
    worg->block_started = 0;
    worg->curline = worg->linum;
}
#+END_SRC

#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_append_string(worgle_d *worg);
#+END_SRC

In this function, the currently active string block is
appened to the currently active code block. It is called
when the parser is inside a code block (aka =MODE_CODE=).

The current line number is checked if it
is a valid (positive) value. A negative value indicates an
properly initialized, but unset value. This will happen if
the initial code block begins with a reference. A negative
value will cause invalid line declarations in the generated
code.

#+NAME: functions
#+BEGIN_SRC c
void worgle_append_string(worgle_d *worg)
{
    worgle_segment *seg;
    if(worg->curblock == NULL) return;
    if(worg->curline < 0) return;
    seg = worgle_block_append_string(worg->curblock,
                                     &worg->block,
                                     worg->curline,
                                     &worg->curbuf->filename);
    <<worgle_segment_string_set_id>>
}
#+END_SRC

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_append_reference(worgle_d *worg, worgle_string *ref);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_append_reference(worgle_d *worg, worgle_string *ref)
{
    worgle_segment *seg;
    if(worg->curblock == NULL) return;
    seg = worgle_block_append_reference(worg->curblock,
                                        ref,
                                        worg->linum,
                                        &worg->curbuf->filename);
    <<worgle_segment_reference_set_id>>
}
#+END_SRC

#+NAME: static_function_declarations
#+BEGIN_SRC c
static int check_for_reference(char *line , size_t size, worgle_string *str);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
static int check_for_reference(char *line , size_t size, worgle_string *str)
{
    int mode;
    size_t n;
    mode = 0;

    str->size = 0;
    str->str = NULL;
    for(n = 0; n < size; n++) {
        if(mode < 0) break;
        switch(mode) {
            case 0: /* spaces */
                if(line[n] == ' ') continue;
                else if(line[n] == '<') mode = 1;
                else mode = -1;
                break;
            case 1: /* second < */
                if(line[n] == '<') mode = 2;
                else mode = -1;
                break;
            case 2: /* word setup */
                str->str = &line[n];
                str->size++;
                mode = 3;
                break;
            case 3: /* the word */
                if(line[n] == '>') {
                    mode = 4;
                    break;
                }
                str->size++;
                break;
            case 4: /* last > */
                if(line[n] == '>') mode = 5;
                else mode = -1;
                break;
        }
    }

    return (mode == 5);
}
#+END_SRC
*** Top Level Parsing Function
The second phase of the program is the parsing stage.

The parsing stage will parse files line-by-line. The program will find a line
by skimming through the block up to a line break character, then pass
that off to be parsed. Line by line, the parser will read the program and
produce a structure of the tangled code in memory.

Parsing is done via the function =parse_file=.

#+NAME: local_variables
#+BEGIN_SRC c
int i;
#+END_SRC

#+NAME: parsing
#+BEGIN_SRC c
for(i = 0; i < worg.nbuffers; i++) {
    rc = parse_file(&worg, i);
    if(rc) goto cleanup;
}
#+END_SRC

The =parse_file= function will parse a file whose filename is located
in the index position denoted by =file=.

#+NAME: function_declarations
#+BEGIN_SRC c
int parse_file(worgle_d *worg, int file);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int parse_file(worgle_d *worg, int file)
{
    char *buf;
    size_t size;
    worgle_textbuf *curbuf;
    <<parser_local_variables>>

    curbuf = &worg->buffers[file];
    buf = curbuf->buf;
    size = curbuf->size;
    worg->curbuf = curbuf;
#ifndef WORGLITE
    worg->curorg = &worg->orgs[file];
#endif
    <<parser_initialization>>
    while(1) {
        <<getline>>
        if(mode == MODE_ORG) {
            <<parse_mode_org>>
        } else if(mode == MODE_CODE) {
            <<parse_mode_code>>
        } else if(mode == MODE_BEGINCODE) {
            <<parse_mode_begincode>>
        }
    }
    return rc;
}
#+END_SRC
*** Parser Local Variables
The parsing stage requires a local variable called =str= to be used from time
to time. Not sure where else to put this.

#+NAME: parser_local_variables
#+BEGIN_SRC c
worgle_string str;
#+END_SRC

#+NAME: parser_initialization
#+BEGIN_SRC c
worgle_string_init(&str);
#+END_SRC

=line= refers to the pointer address that the line will write to.

#+NAME: parser_local_variables
#+BEGIN_SRC c
char *line;
#+END_SRC

#+NAME: parser_initialization
#+BEGIN_SRC c
line = NULL;
#+END_SRC

=pos= refers to the current buffer position.

#+NAME: parser_local_variables
#+BEGIN_SRC c
size_t pos;
#+END_SRC

#+NAME: parser_initialization
#+BEGIN_SRC c
pos = 0;
#+END_SRC

This is the local variable =read=.

#+NAME: parser_local_variables
#+BEGIN_SRC c
size_t read;
#+END_SRC

The overall parser mode state is set by the local variable =mode=.

#+NAME: parser_local_variables
#+BEGIN_SRC c
int mode;
#+END_SRC

It is set to be the initial mode of =MODE_ORG=.

#+NAME: parser_initialization
#+BEGIN_SRC c
mode = MODE_ORG;
#+END_SRC

The main return code determines the overall state of the program.

#+NAME: parser_local_variables
#+BEGIN_SRC c
int rc;
#+END_SRC

By default, it is set to be okay, which is 0 on POSIX systems.

#+NAME: parser_initialization
#+BEGIN_SRC c
rc = 0;
#+END_SRC

The getline function used by the parser returns a status code, which tells
the program when it has reached the end of the file.

#+NAME: parser_local_variables
#+BEGIN_SRC c
int status;
#+END_SRC

This is set to be TRUE (1) by default.

#+NAME: parser_initialization
#+BEGIN_SRC c
status = 0;
#+END_SRC

*** Reading a line at a time
Despite being loaded into memory, the program still reads in code one line
at a time. The parsing relies on new line feeds to denote the beginnings
and endings of sections and code references.

Before reading the line, the line number inside worgle is incremented.

In order to handle multiple files, this value must explicitely be reset
to be zero every time inside of the =parse_file= function.

#+NAME: parser_initialization
#+BEGIN_SRC c
worg->linum = 0;
#+END_SRC

A special readline function has been written based on =getline= that reads
lines of text from an allocated block of text. This function is called
=worgle_getline=.

After the line has been read, the program checks the return code =status=.
If all the lines of text have been read, the program breaks out of the
while loop.

#+NAME: getline
#+BEGIN_SRC c
worg->linum++;
status = worgle_getline(buf, &line, &pos, &read, size);
if(!status) break;
#+END_SRC

#+NAME: static_function_declarations
#+BEGIN_SRC c
static int worgle_getline(char *fullbuf,
                  char **line,
                  size_t *pos,
                  size_t *line_size,
                  size_t buf_size);
#+END_SRC


=fullbuf= refers to the full text buffer.

=line= is a pointer where the current line will be stored.

=pos= is the current buffer position.

=line_size= is a variable written to that returns the size of the line. This
includes the line break character.

=buf_size= is the size of the whole buffer.

#+NAME:functions
#+BEGIN_SRC c
static int worgle_getline(char *fullbuf,
                  char **line,
                  size_t *pos,
                  size_t *line_size,
                  size_t buf_size)
{
    size_t p;
    size_t s;
    *line_size = 0;
    p = *pos;
    *line = &fullbuf[p];
    s = 0;
    while(1) {
        s++;
        if(p >= buf_size) return 0;
        if(fullbuf[p] == '\n') {
            *pos = p + 1;
            *line_size = s;
            return 1;
        }
        p++;
    }
}
#+END_SRC
** Generation
The last phase of the program is code generation.

A parsed file generates a structure of how the code will look. The generation
stage involves iterating through the structure and producing the code.

Due to the hierarchical nature of the data structures,
the generation stage is surprisingly elegant with a single expanding entry
point.

At the very top, generation
consists of writing all the files in the filelist. Each file will then go
and write the top-most block associated with that file. A block will then
write the segment list it has embedded inside of it. A segment will either
write a string literal to disk, or a recursively expand block reference.

#+NAME:generation
#+BEGIN_SRC c
if(!rc && tangle_code) if(!worgle_generate(&worg)) rc = 1;
#+END_SRC

#+NAME:function_declarations
#+BEGIN_SRC c
int worgle_generate(worgle_d *worg);
#+END_SRC

#+NAME:functions
#+BEGIN_SRC c
int worgle_generate(worgle_d *worg)
{
    return worgle_filelist_write(&worg->flist, &worg->dict);
}
#+END_SRC

If the =use_warnings= flag is turned on, Worgle will scan the dictionary
after generation and flag warnings about any unused blocks.

#+NAME:generation
#+BEGIN_SRC c
if(!rc && use_warnings) rc = worgle_warn_unused(&worg);
#+END_SRC

** Cleanup
At the end up the program, all allocated memory is freed via =worgle_free=.
#+NAME: cleanup
#+BEGIN_SRC c
cleanup:
worgle_free(&worg);
return rc;
#+END_SRC
* Core Data Structures
The Worgle/Orgle program is very much a data-structure driven program.
Understanding the hierarchy of data here will provide a clear picture for
how the tangling works.

#+NAME: structs
#+BEGIN_SRC c
<<worgle_string>>
<<worgle_segment>>
<<worgle_block>>
<<worgle_blocklist>>
<<worgle_hashmap>>
<<worgle_file>>
<<worgle_filelist>>
<<worgle_textbuf>>
<<worgle_orglet>>
<<worgle_orgfile>>
<<worgle_struct>>
#+END_SRC
** Top Level Struct
All Worgle operations are contained in a top-level struct called =worgle_d=.
For the most part, this struct aims to be dynamically populated.

#+NAME:typedefs
#+BEGIN_SRC c
typedef struct worgle_d worgle_d;
#+END_SRC

#+NAME:worgle_struct
#+BEGIN_SRC c
struct worgle_d {
    <<worgle_struct_contents>>
};
#+END_SRC
*** Worgle Initialization

Worgle data is initialized using the function =worgle_init=.

#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_init(worgle_d *worg);
#+END_SRC

#+NAME:functions
#+BEGIN_SRC c
void worgle_init(worgle_d *worg)
{
<<worgle_init>>
}
#+END_SRC

*** Worgle Deallocation

When worgle is done, the program deallocates memory using the function
=worgle_free=.

#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_free(worgle_d *worg);
#+END_SRC

#+NAME:functions
#+BEGIN_SRC c
void worgle_free(worgle_d *worg)
{
    int i;
    <<worgle_free>>
}
#+END_SRC

*** Worgle Data
**** Text Block
The =block= variable is used to store multi-line text blocks
being parsed, such as those in a code block when the parser,
such as when the parser is in =MODE_CODE=.

It may also be used to parse content while the parser in
mode =MODE_ORG=.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
worgle_string block;
#+END_SRC

It is initialized to be an empty string.

#+NAME:worgle_init
#+BEGIN_SRC c
worgle_string_init(&worg->block);
#+END_SRC
**** Current Line

The starting line number of the current block is stored in a variable called
=curline=.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
long curline;
#+END_SRC

The current line is initialized to be negative value to mark that it has not
been set yet.
#+NAME:worgle_init
#+BEGIN_SRC c
worg->curline = -1;
#+END_SRC
**** Block Started Flag
The block started flag is used by the parser to check whether or not a code
block was started on the last iteration.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
int block_started;
#+END_SRC

It is set to be FALSE (0).

#+NAME:worgle_init
#+BEGIN_SRC c
worg->block_started = 0;
#+END_SRC
**** Dictionary

All code blocks are stored in a dictionary, also referred to here as a hash map.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
worgle_hashmap dict;
#+END_SRC

The dictionary is initialized using the function =worgle_hashmap_init=.
#+NAME:worgle_init
#+BEGIN_SRC c
worgle_hashmap_init(&worg->dict);
#+END_SRC

When free-ing time comes around, the hashmap will free itself using the function
=worgle_hashmap_free=.

#+NAME: worgle_free
#+BEGIN_SRC c
worgle_hashmap_free(&worg->dict);
#+END_SRC
**** File List

All files to be written to are stored in a local file list called =flist=.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
worgle_filelist flist;
#+END_SRC

Initialization.

#+NAME:worgle_init
#+BEGIN_SRC c
worgle_filelist_init(&worg->flist);
#+END_SRC

Destruction.

#+NAME:worgle_free
#+BEGIN_SRC c
worgle_filelist_free(&worg->flist);
#+END_SRC
**** Text Buffer
Text files are loaded into buffers, encapsulated as a type
=worgle_textbuf=. The currently used text buffer is stored in
the variable =curbuf=. Buffers are stored in an array of text
buffers known as =buflist=.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
worgle_textbuf *curbuf;
worgle_textbuf *buffers;
int nbuffers;
#+END_SRC

The loaded happens after initialization, so the buffer is set to be NULL for
now.

#+NAME:worgle_init
#+BEGIN_SRC c
worg->curbuf = NULL;
worg->buffers = NULL;
worg->nbuffers = 0;
#+END_SRC

If the buffer is non-null, the memory will be freed.

#+NAME: worgle_free
#+BEGIN_SRC c
for(i = 0; i < worg->nbuffers; i++) {
    worgle_textbuf_free(&worg->buffers[i]);
}
if(worg->nbuffers > 0) free(worg->buffers);
#+END_SRC
**** Current Block
A pointer to the currently populated code block is stored in a variable called
=curblock=.

#+NAME:worgle_struct_contents
#+BEGIN_SRC c
worgle_block *curblock;
#+END_SRC

There is no block on startup, so set it to be NULL.
#+NAME:worgle_init
#+BEGIN_SRC c
worg->curblock = NULL;
#+END_SRC
**** Line Number

The currently parsed line number is stored in a variable called =linum=.

#+NAME: worgle_struct_contents
#+BEGIN_SRC c
size_t linum;
#+END_SRC

The line number is incremented, so the starting value starts at 0. Line 1 is
the first line. Do not be tempted to set this to be -1, because it won't work.

#+NAME:worgle_init
#+BEGIN_SRC c
worg->linum = 0;
#+END_SRC
**** Orgfile Array
The orgfile array keeps track of data representations
of orgfiles to be tangled.
***** Declaration + Initialization
#+NAME: worgle_struct_contents
#+BEGIN_SRC c
worgle_orgfile *orgs;
worgle_orgfile *curorg;
#+END_SRC
#+NAME:worgle_init
#+BEGIN_SRC c
worg->orgs = NULL;
worg->curorg = NULL;
#+END_SRC
***** Freeing
Org files allocated must be freed.
#+NAME: worgle_free
#+BEGIN_SRC c
if(worg->orgs != NULL && worg->nbuffers > 0) {
    for(i = 0; i < worg->nbuffers; i++) {
        worgle_orgfile_free(&worg->orgs[i]);
    }
    free(worg->orgs);
}
#+END_SRC
***** Appending an Org file
This happens when the main file list is being populated.
#+NAME: append_org_file
#+BEGIN_SRC c
if(worg->nbuffers == 1) {
    worg->orgs = calloc(1, sizeof(worgle_orgfile));
} else {
    worg->orgs = realloc(worg->orgs,
                         sizeof(worgle_orgfile) *
                         worg->nbuffers);
}
if(worg->nbuffers > 0) {
    worgle_orgfile_init(&worg->orgs[worg->nbuffers - 1]);
}
#+END_SRC
**** Program ID
The program id is a integer value primarily used to
distinguish itself from other programs in a generated
database. This functionality allows portions of a program
to be incrementally updated/written to a database.
#+NAME: worgle_struct_contents
#+BEGIN_SRC c
int prog;
#+END_SRC
#+NAME:worgle_init
#+BEGIN_SRC c
worg->prog = 0;
#+END_SRC
** String
A string is a wrapper around a raw =char= pointer and a size. This is used
as the base string literal.

#+NAME: worgle_string_contents
#+BEGIN_SRC c
char *str;
size_t size;
#+END_SRC

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_string worgle_string;
#+END_SRC

#+NAME: worgle_string
#+BEGIN_SRC c
struct worgle_string {
    <<worgle_string_contents>>
};
#+END_SRC
*** Reset or initialize a string

Strings in worgle are reset with the function =worgle_string_reset=.

#+NAME: worgle_string_init
#+BEGIN_SRC c
str->str = NULL;
str->size = 0;
#+END_SRC

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_string_reset(worgle_string *str);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_string_reset(worgle_string *str)
{
    <<worgle_string_init>>
}
#+END_SRC

A string being initialized is identical to a string being reset. The function
=worgle_string_init= is just a wrapper around =worgle_string_reset=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_string_init(worgle_string *str);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_string_init(worgle_string *str)
{
    worgle_string_reset(str);
}
#+END_SRC
*** Writing a String

A string is written to a particular filehandle with the function
=worgle_string_write=.Worgle strings are *not* zero-terminated
and can't be used in functions like printf.


#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_string_write(FILE *fp, worgle_string *str);
#+END_SRC

This function is a wrapper around a call to =fwrite=.

#+NAME: functions
#+BEGIN_SRC c
int worgle_string_write(FILE *fp, worgle_string *str)
{
    return fwrite(str->str, 1, str->size, fp);
}
#+END_SRC
** Segment
A segment turns a string into a linked list component that has a type.
A segment type flag can either be a text chunk or a reference.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_segment worgle_segment;
#+END_SRC

#+NAME: worgle_segment
#+BEGIN_SRC c
enum {
<<worgle_segment_types>>
};
struct worgle_segment {
    <<worgle_segment_contents>>
};
#+END_SRC

#+NAME: worgle_segment_contents
#+BEGIN_SRC c
int type;
worgle_string str;
<<worgle_segment_line_control>>
worgle_segment *nxt;
#+END_SRC

Segments also keep track of where they are in the original org file.
This information can be used to generate line control preprocessor commands
for C/C++.

#+NAME: worgle_segment_line_control
#+BEGIN_SRC c
size_t linum;
worgle_string *filename;
#+END_SRC
*** Text Chunk Type

A text chunk is a literal string of text.

When a text chunk segment is processed, it gets written to file directly.

#+NAME: worgle_segment_types
#+BEGIN_SRC c
SEGTYPE_TEXT,
#+END_SRC
*** Reference Type

A reference contains a string reference to another block.

When a reference
segment gets processed, it looks up the reference and processes all the
segements in that code block.

#+NAME: worgle_segment_types
#+BEGIN_SRC c
SEGTYPE_REFERENCE
#+END_SRC
*** Initializing a Segment
A segment is initialized with the function =worgle_segment_init=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_segment_init(worgle_segment *s,
                        int type,
                        worgle_string *str,
                        worgle_string *filename,
                        size_t linum);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_segment_init(worgle_segment *s,
                        int type,
                        worgle_string *str,
                        worgle_string *filename,
                        size_t linum)
{
   <<worgle_segment_init>>
}
#+END_SRC

#+NAME: worgle_segment_init
#+BEGIN_SRC c
s->type = type;
s->str = *str;
s->filename = filename;
s->linum = linum;
s->nxt = NULL;
#+END_SRC
*** Writing a Segment

A segment is written to a file handle using the function =worgle_segment_write=.
In addition to taking in a filehandle and segment, a hashmap is also passed
in in the event that the segment is a reference.

On sucess, the function returns TRUE (1). On failure, FALSE (0).

#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_segment_write(worgle_segment *s, worgle_hashmap *h, FILE *fp);
#+END_SRC

Different behaviors happen depending on the segment type.

If the segment is a chunk of text (=SEGTYPE_TEXT=), then the string
is written. If the =use_debug= global variable is enabled, then C preprocessor
macros are written indicating the position from the original file. This
only needs to happen for text blocks and not references.

If the segment is a reference (=SEGTYPE_REFERENCE=), the
function attempts to look up a block and write it to disk. If it cannot
find the reference, a warning is flashed to screen. If the warning
mode is soft, the error code returns TRUE. If warning errors are turned on,
it returns FALSE.

#+NAME: functions
#+BEGIN_SRC c
int worgle_segment_write(worgle_segment *s, worgle_hashmap *h, FILE *fp)
{
    worgle_block *b;
    if(s->type == SEGTYPE_TEXT) {
        if(use_debug) {
            fprintf(fp, "#line %lu \"", s->linum);
            worgle_string_write(fp, s->filename);
            fprintf(fp, "\"\n");
        }
        worgle_string_write(fp, &s->str);
    } else {
        if(!worgle_hashmap_find(h, &s->str, &b)) {
            fprintf(stderr, "Warning: could not find reference segment '");
            worgle_string_write(stderr, &s->str);
            fprintf(stderr, "'\n");
            if(use_warnings == 2) {
                return 0;
            } else {
                return 1;
            }
        }
        return worgle_block_write(b, h, fp);
    }

    return 1;
}
#+END_SRC
*** Segment Type Checks
All segment types can be checked with a few functions, without needing to know
any of the type macros.
#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_segment_is_text(worgle_segment *s);
int worgle_segment_is_reference(worgle_segment *s);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int worgle_segment_is_text(worgle_segment *s)
{
    return s->type == SEGTYPE_TEXT;
}

int worgle_segment_is_reference(worgle_segment *s)
{
    return s->type == SEGTYPE_REFERENCE;
}
#+END_SRC
** Code Block
A code block is a top-level unit that stores some amount of code. It is
made up of a list of segments. Every code block has a unique name.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_block worgle_block;
#+END_SRC

#+NAME: worgle_block
#+BEGIN_SRC c
struct worgle_block {
    <<worgle_block_contents>>
};
#+END_SRC

#+NAME: worgle_block_contents
#+BEGIN_SRC c
int nsegs;
worgle_segment *head;
worgle_segment *tail;
worgle_string name;
int am_i_used;
worgle_block *nxt;
#+END_SRC
*** Initializing a code block

A worgle code block is initialized using the function =worgle_block_init=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_block_init(worgle_block *b);
#+END_SRC

The initialization will zero out all the variables related to the segment
linked list, as well as initialize the string holding the name of the block.

#+NAME: functions
#+BEGIN_SRC c
void worgle_block_init(worgle_block *b)
{
    <<worgle_block_init>>
}
#+END_SRC

#+NAME: worgle_block_init
#+BEGIN_SRC c
b->nsegs = 0;
b->head = NULL;
b->tail = NULL;
b->nxt = NULL;
b->am_i_used = 0;
worgle_string_init(&b->name);
#+END_SRC
*** Freeing a code block
A code block is freed using the function =worgle_block_free=.

#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_block_free(worgle_block *lst);
#+END_SRC

This function iterates through the segment linked list contained
inside the block, and frees each one. Since there is nothing to
free below a segment, the standard free function is called directly.

#+NAME: functions
#+BEGIN_SRC c
void worgle_block_free(worgle_block *lst)
{
    worgle_segment *s;
    worgle_segment *nxt;
    int n;
    s = lst->head;
    for(n = 0; n < lst->nsegs; n++) {
        nxt = s->nxt;
        free(s);
        s = nxt;
    }
}
#+END_SRC
*** Appending a segment to a code block
A generic segment is appended to a code block with the function.
=worgle_block_append_segment=.
The block =b=, name of the block =str=, and type =type= are mandatory parameters
which describe the segment. The location in the file is also required, so the
line number =linum= and name of file =filename= are also provided as well.
This function is called inside of a type-specific append function instead of
being called directly.


#+NAME: function_declarations
#+BEGIN_SRC c
worgle_segment* worgle_block_append_segment(worgle_block *b,
                                            worgle_string *str,
                                            int type,
                                            size_t linum,
                                            worgle_string *filename);
#+END_SRC

It is worthwhile to note that it is in this function that a data
segment type gets allocated.

#+NAME: functions
#+BEGIN_SRC c
worgle_segment* worgle_block_append_segment(worgle_block *b,
                                            worgle_string *str,
                                            int type,
                                            size_t linum,
                                            worgle_string *filename)
{
    worgle_segment *s;
    s = malloc(sizeof(worgle_segment));
    if(b->nsegs == 0) {
        b->head = s;
        b->tail = s;
    }
    worgle_segment_init(s, type, str, filename, linum);
    b->tail->nxt = s;
    b->tail = s;
    b->nsegs++;
    return s;
}
#+END_SRC

**** Appending a string segment

A string segment is appended to a code block using the function
=worgle_block_append_string=.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_segment* worgle_block_append_string(worgle_block *b,
                               worgle_string *str,
                               size_t linum,
                               worgle_string *filename);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_segment* worgle_block_append_string(worgle_block *b,
                                           worgle_string *str,
                                           size_t linum,
                                           worgle_string *filename)
{
    return worgle_block_append_segment(b, str, SEGTYPE_TEXT, linum, filename);
}
#+END_SRC
**** Appending a reference segment

A reference segment is appended to a code block using the function
=worgle_block_append_reference=.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_segment* worgle_block_append_reference(worgle_block *b,
                                              worgle_string *str,
                                              size_t linum,
                                              worgle_string *filename);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_segment* worgle_block_append_reference(worgle_block *b,
                                              worgle_string *str,
                                              size_t linum,
                                              worgle_string *filename)
{
    return worgle_block_append_segment(b, str, SEGTYPE_REFERENCE,
                                       linum, filename);
}
#+END_SRC
*** Appending a code block to a code block

In both CWEB and Org-tangle, existing code blocks can be appeneded to in
different sections. Because of how this program works, we get this functionality
for free!
*** Writing a code block to filehandle

Writing a code block to a filehandle can be done using the function
=worgle_block_write=. In addition to the file handle =fp=, an org block
requires a hashmap, which is required in the lower level function
=orgle_segment_write= for expanding code references.

This function returns a boolean TRUE (1) on success or FALSE (0) on failure.

#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_block_write(worgle_block *b, worgle_hashmap *h, FILE *fp);
#+END_SRC

A code block iterates it's segment list, writing each segment to disk.
A block will also be marked as being used, which is useful for supplying
warning information later.

#+NAME: functions
#+BEGIN_SRC c
int worgle_block_write(worgle_block *b, worgle_hashmap *h, FILE *fp)
{
    worgle_segment *s;
    int n;
    s = b->head;
    b->am_i_used = 1;
    for(n = 0; n < b->nsegs; n++) {
        if(!worgle_segment_write(s, h, fp)) return 0;
        s = s->nxt;
    }

    return 1;
}
#+END_SRC

** Code Block List
A code block list is a linked list of blocks, which is used inside of a
hash map.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_blocklist worgle_blocklist;
#+END_SRC

#+NAME: worgle_blocklist
#+BEGIN_SRC c
struct worgle_blocklist {
    int nblocks;
    worgle_block *head;
    worgle_block *tail;
};
#+END_SRC
*** Block List Initialization

A block list is initialized using the function =worgle_blocklist_init=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_blocklist_init(worgle_blocklist *lst);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_blocklist_init(worgle_blocklist *lst)
{
    lst->head = NULL;
    lst->tail = NULL;
    lst->nblocks = 0;
}
#+END_SRC
*** Freeing a Block List

Blocks allocated by the block list are freed using the function
=worgle_blocklist_free=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_blocklist_free(worgle_blocklist *lst);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_blocklist_free(worgle_blocklist *lst)
{
    worgle_block *b;
    worgle_block *nxt;
    int n;
    b = lst->head;
    for(n = 0; n < lst->nblocks; n++) {
        nxt = b->nxt;
        worgle_block_free(b);
        free(b);
        b = nxt;
    }
}
#+END_SRC
*** Appending a Block

An allocated block is appended to a block list using the function
=worgle_blocklist_append=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_blocklist_append(worgle_blocklist *lst, worgle_block *b);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_blocklist_append(worgle_blocklist *lst, worgle_block *b)
{
    if(lst->nblocks == 0) {
        lst->head = b;
        lst->tail = b;
    }
    lst->tail->nxt = b;
    lst->tail = b;
    lst->nblocks++;
}
#+END_SRC
** Hash Map
A hash map is a key-value data structure used as a dictionary for storing
references to code blocks.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_hashmap worgle_hashmap;
#+END_SRC

#+NAME: worgle_hashmap
#+BEGIN_SRC c
#define HASH_SIZE 256
struct worgle_hashmap {
    worgle_blocklist blk[HASH_SIZE];
    int nwords;
};
#+END_SRC
*** Hash map Initialization

A hash map is initialized using the function =worgle_hashmap_init=

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_hashmap_init(worgle_hashmap *h);
#+END_SRC

A hashmap is composed of an array of block lists which must be initialized.

#+NAME: functions
#+BEGIN_SRC c
void worgle_hashmap_init(worgle_hashmap *h)
{
    int n;
    h->nwords = 0;
    for(n = 0; n < HASH_SIZE; n++) {
        worgle_blocklist_init(&h->blk[n]);
    }
}
#+END_SRC
*** Freeing a Hash Map

Information allocated inside the hash map is freed using the function
=worgle_hashmap_free=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_hashmap_free(worgle_hashmap *h);
#+END_SRC

To free a hash map is to free each block list in the array.

#+NAME: functions
#+BEGIN_SRC c
void worgle_hashmap_free(worgle_hashmap *h)
{
    int n;
    for(n = 0; n < HASH_SIZE; n++) {
        worgle_blocklist_free(&h->blk[n]);
    }
}
#+END_SRC
*** Looking up an entry

A hashmap lookup can be done with the function =worgle_hashmap_find=.
This will attempt to look for a value with the key value =name=, and
save it in the block pointer =b=. If nothing is found, the function returns
FALSE (0). On success, TRUE (1).

#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_hashmap_find(worgle_hashmap *h, worgle_string *name, worgle_block **b);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
<<hashmap_hasher>>
int worgle_hashmap_find(worgle_hashmap *h, worgle_string *name, worgle_block **b)
{
    int pos;
    worgle_blocklist *lst;
    int n;
    worgle_block *blk;
    pos = hash(name->str, name->size);
    lst = &h->blk[pos];

    blk = lst->head;
    for(n = 0; n < lst->nblocks; n++) {
        if(name->size == blk->name.size) {
            if(!strncmp(name->str, blk->name.str, name->size)) {
                *b = blk;
                return 1;
            }
        }
        blk = blk->nxt;
    }
    return 0;
}
#+END_SRC

Like any hashmap, a hashing algorithm is used to to compute which list to place
the entry in. This is one I've used on a number of projects now.

#+NAME: hashmap_hasher
#+BEGIN_SRC c
static int hash(const char *str, size_t size)
{
    unsigned int h = 5381;
    size_t i = 0;

    for(i = 0; i < size; i++) {
        h = ((h << 5) + h) ^ str[i];
        h %= 0x7FFFFFFF;
    }

    return h % HASH_SIZE;
}
#+END_SRC
*** Getting an entry
To "get" an entry means to return a block if it exists or not. Return
an entry that exists, or make a new one. This can be done with the function
=worgle_hashmap_get=.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_block * worgle_hashmap_get(worgle_hashmap *h, worgle_string *name);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_block * worgle_hashmap_get(worgle_hashmap *h, worgle_string *name)
{
    worgle_block *b;
    worgle_blocklist *lst;
    int pos;

    if(worgle_hashmap_find(h, name, &b)) return b;
    pos = hash(name->str, name->size);
    b = NULL;
    b = malloc(sizeof(worgle_block));
    worgle_block_init(b);
    b->name = *name;
    lst = &h->blk[pos];
    worgle_blocklist_append(lst, b);
    return b;
}
#+END_SRC
** File
A worgle file is an abstraction for a single file worgle will write to. Every
file has a filename, and a top-level code block. A worgle does not have a
filehandle. Files will only be created at the generation stage.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_file worgle_file;
#+END_SRC

#+NAME: worgle_file
#+BEGIN_SRC c
struct worgle_file {
    <<worgle_file_contents>>
};
#+END_SRC

#+NAME: worgle_file_contents
#+BEGIN_SRC c
worgle_string filename;
worgle_block *top;
worgle_file *nxt;
#+END_SRC
*** Writing A File to a filehandle

A file is writen to a filehandle using the function =worgle_file_write=.
A hashmap is also required because it contains all the named code blocks
needed for any code expansion.

#+NAME:function_declarations
#+BEGIN_SRC c
int worgle_file_write(worgle_file *f, worgle_hashmap *h);
#+END_SRC

A filehandle is opened, the top-most code block is written using
=worgle_block_write=, and then the file is closed.

Because worgle strings are not zero terminated, they must be copied to a
temporary string buffer with a null terminator. Any filename greater than
127 characters will be truncated.

#+NAME: functions
#+BEGIN_SRC c
int worgle_file_write(worgle_file *f, worgle_hashmap *h)
{
    FILE *fp;
    char tmp[128];
    size_t n;
    size_t size;
    int rc;

    if(f->filename.size > 128) size = 127;
    else size = f->filename.size;
    for(n = 0; n < size; n++) tmp[n] = f->filename.str[n];
    tmp[size] = 0;

    fp = fopen(tmp, "w");

    rc = worgle_block_write(f->top, h, fp);

    fclose(fp);
    return rc;
}
#+END_SRC
** The File List
A file list is a linked list of worgle files.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_filelist worgle_filelist;
#+END_SRC

#+NAME: worgle_filelist
#+BEGIN_SRC c
struct worgle_filelist {
    worgle_file *head;
    worgle_file *tail;
    int nfiles;
};
#+END_SRC
*** Initializing a file list

A file list is zeroed out and initialized using the function
=worgle_filelist_init=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_filelist_init(worgle_filelist *flist);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_filelist_init(worgle_filelist *flist)
{
    flist->head = NULL;
    flist->tail = NULL;
    flist->nfiles = 0;
}
#+END_SRC

*** Freeing a file list

A filelist is freed using the function =worgle_filelist_free=.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_filelist_free(worgle_filelist *flist);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_filelist_free(worgle_filelist *flist)
{
    worgle_file *f;
    worgle_file *nxt;
    int n;
    f = flist->head;
    for(n = 0; n < flist->nfiles; n++) {
        nxt = f->nxt;
        free(f);
        f = nxt;
    }
}
#+END_SRC
*** Appending a file to a file list

A file is appended to the file list using the function =worgle_filelist_append=.
The name, as well as the well as the top-level code block are required here.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_file* worgle_filelist_append(worgle_filelist *flist,
                           worgle_string *name,
                           worgle_block *top);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_file* worgle_filelist_append(worgle_filelist *flist,
                           worgle_string *name,
                           worgle_block *top)
{
    worgle_file *f;
    f = malloc(sizeof(worgle_file));
    f->filename = *name;
    f->top = top;
    f->nxt = NULL;
    <<worgle_file_init_id>>

    if(flist->nfiles == 0) {
        flist->head = f;
        flist->tail = f;
    }
    flist->tail->nxt = f;
    flist->tail = f;
    flist->nfiles++;
    return f;
}
#+END_SRC
*** Writing a filelist to disk
A file list can be appended using the function =worgle_filelist_write=.

A hashmap containing all named code blocks all that is required.

#+NAME: function_declarations
#+BEGIN_SRC c
int worgle_filelist_write(worgle_filelist *flist, worgle_hashmap *h);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
int worgle_filelist_write(worgle_filelist *flist, worgle_hashmap *h)
{
    worgle_file *f;
    int n;

    f = flist->head;
    for(n = 0; n < flist->nfiles; n++) {
        if(!worgle_file_write(f, h)) return 0;
        f = f->nxt;
    }

    return 1;
}
#+END_SRC
** Text Buffer
Files in memory are stored in a text buffer known as a =worgle_textbuf=.

#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_textbuf worgle_textbuf;
#+END_SRC

#+NAME: worgle_textbuf
#+BEGIN_SRC c
struct worgle_textbuf {
    char *buf;
    size_t size;
    worgle_string filename;
};
#+END_SRC

*** Zeroing out a text buffer
A text buffer is zeroed out with the function =worgle_textbuf_zero=.
This is action will set things to be NULL an zero.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_textbuf_zero(worgle_textbuf *txt);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_textbuf_zero(worgle_textbuf *txt)
{
    txt->buf = NULL;
    worgle_string_init(&txt->filename);
    txt->size = 0;
}
#+END_SRC
*** Initializing a text buffer
A text buffer is fully initialized with the function =worgle_textbuf_init=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_textbuf_init(worgle_textbuf *txt,
                         char *buf,
                         size_t bufsize);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_textbuf_init(worgle_textbuf *txt,
                         char *buf,
                         size_t bufsize)
{
    txt->buf = buf;
    txt->size = bufsize;
}
#+END_SRC
*** Freeing a text buffer
A text buffer is in charge of freeing a buffer it holds. This is done
with the function =worgle_textbuf_free=. It is assumed that
the memory for the filename string is handled elsewhere. It is also
assumed that the buffer was allocated via system =malloc=, so it
uses the system =free= function.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_textbuf_free(worgle_textbuf *txt);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_textbuf_free(worgle_textbuf *txt)
{
    if(txt->buf != NULL) free(txt->buf);
    worgle_textbuf_zero(txt);
}
#+END_SRC
** UUID
Every data structure has a Universally Unique Identifier
(UUID). This concept was added later on in order to better
accomodate the Worgle Database interface.
*** Worgle Long Typedef
All UUIDs have a type of =worgle_long=, which is set to be an unsigned long.
UUIDs begin at 1, with 0 indicating an uninitialized or unset ID number.
#+NAME:typedefs
#+BEGIN_SRC c
typedef unsigned long worgle_long;
#+END_SRC
*** Top-level UUID counter
UUID management is done via a reference counter called =UUID_count=.
#+NAME: worgle_struct_contents
#+BEGIN_SRC c
worgle_long UUID_count;
#+END_SRC
It is initialized to be 1, the first valid UUID.
When using the counter, the Worgle process will return then increment. This
will ensure that the UUID will be valid no matter what.
#+NAME: worgle_init
#+BEGIN_SRC c
worg->UUID_count = 1;
#+END_SRC

A new UUID is generated by returning the UUID_counter, then
incrementing it.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_long worgle_uuid_new(worgle_d *worg);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_long worgle_uuid_new(worgle_d *worg)
{
    return worg->UUID_count++;
}
#+END_SRC

# # Not String IDs are needed! Keeping it commented it out for now.
# *** String ID
# A worgle string ID is set with =worgle_string_id_set= and retrieved with
# =worgle_string_id_get=.
#
# #+NAME: worgle_string_contents
# #+BEGIN_SRC c
# worgle_long id;
# #+END_SRC
# #+NAME: worgle_string_init
# #+BEGIN_SRC c
# str->id = 0;
# #+END_SRC
#
# #+NAME: function_declarations
# #+BEGIN_SRC c
# worgle_long worgle_string_id_get(worgle_string *str);
# void worgle_string_id_set(worgle_string *str, worgle_long id);
# #+END_SRC
#
# #+NAME: functions
# #+BEGIN_SRC c
# worgle_long worgle_string_id_get(worgle_string *str)
# {
#     return str->id;
# }
# void worgle_string_id_set(worgle_string *str, worgle_long id)
# {
#     str->id = id;
# }
# #+END_SRC
*** Segment ID
A segment ID is retrieved using =worgle_segment_id_get= and set using
=worgle_segment_id_set=. This is the lowest level component where a
UUID is required. The =worgle_string= type is lower than a =worgle_segment=,
but it is always encapsulated in a =worgle_segment=.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_long worgle_segment_id_get(worgle_segment *s);
void worgle_segment_id_set(worgle_segment *s, worgle_long id);
#+END_SRC

#+NAME: worgle_segment_contents
#+BEGIN_SRC c
worgle_long id;
#+END_SRC

#+NAME: worgle_segment_init
#+BEGIN_SRC c
s->id = 0;
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_long worgle_segment_id_get(worgle_segment *s)
{
    return s->id;
}

void worgle_segment_id_set(worgle_segment *s, worgle_long id)
{
    s->id = id;
}
#+END_SRC

Segment UUIDs are assigned in two places: when a reference is assigned,
and when string is assigned.

#+NAME: worgle_segment_string_set_id
#+BEGIN_SRC c
worgle_segment_id_set(seg, worgle_uuid_new(worg));
#+END_SRC

#+NAME: worgle_segment_reference_set_id
#+BEGIN_SRC c
worgle_segment_id_set(seg, worgle_uuid_new(worg));
#+END_SRC
*** Block ID
A block ID is retrieved using =worgle_block_id_get= and set using
=worgle_block_id_set=.

#+NAME: function_declarations
#+BEGIN_SRC c
worgle_long worgle_block_id_get(worgle_block *b);
void worgle_block_id_set(worgle_block *b, worgle_long id);
#+END_SRC

#+NAME: worgle_block_contents
#+BEGIN_SRC c
worgle_long id;
#+END_SRC

#+NAME: worgle_block_init
#+BEGIN_SRC c
b->id = 0;
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
worgle_long worgle_block_id_get(worgle_block *b)
{
    return b->id;
}

void worgle_block_id_set(worgle_block *b, worgle_long id)
{
    b->id = id;
}
#+END_SRC

The worgle block ID is set inside of =worgle_begin_block= when
a [[Beginning a new block][new block is started]].
In this section a previously allocated block is retrieved, or a new
block is created entirely. A newly allocated block will have an id
of 0. If this is the case, the block will be assigned a UUID. The new block
also has a string name, so this needs to be assigned as well.

#+NAME: worgle_block_set_id
#+BEGIN_SRC c
if(worgle_block_id_get(worg->curblock) == 0) {
    worgle_block_id_set(worg->curblock, worgle_uuid_new(worg));
}
#+END_SRC
*** File ID
#+NAME: worgle_file_contents
#+BEGIN_SRC c
worgle_long id;
#+END_SRC

#+NAME: worgle_file_init_id
#+BEGIN_SRC c
f->id = 0;
#+END_SRC

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_file_id_set(worgle_file *f, worgle_long id);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_file_id_set(worgle_file *f, worgle_long id)
{
    f->id = id;
}
#+END_SRC

#+NAME: worgle_file_set_id
#+BEGIN_SRC c
worgle_file_id_set(f, worgle_uuid_new(worg));
#+END_SRC
*** Orglet ID
#+NAME: worgle_orglet_id
#+BEGIN_SRC c
worgle_long id;
#+END_SRC

#+NAME: worgle_orglet_id_init
#+BEGIN_SRC c
orglet->id = 0;
#+END_SRC

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orglet_id_set(worgle_orglet *orglet,
                           worgle_long id);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_orglet_id_set(worgle_orglet *orglet,
                           worgle_long id)
{
    orglet->id = id;
}
#+END_SRC

#+NAME: worgle_orglet_set_id
#+BEGIN_SRC c
worgle_orglet_id_set(orglet, worgle_uuid_new(worg));
#+END_SRC
** DONE Org File
CLOSED: [2019-09-12 Thu 09:59]
A =worgle_orgfile= is a data type for an org file,
represented as a list of =worgle_orglets=.
*** Struct
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_orgfile worgle_orgfile;
#+END_SRC
#+NAME: worgle_orgfile
#+BEGIN_SRC c
struct worgle_orgfile {
    worgle_orglet *head;
    worgle_orglet *tail;
    int size;
};
#+END_SRC
*** DONE Initialization
CLOSED: [2019-09-12 Thu 07:12]
An org file type is initialized with =worgle_orgfile_init=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orgfile_init(worgle_orgfile *org);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_init(worgle_orgfile *org)
{
    org->head = NULL;
    org->tail = NULL;
    org->size = 0;
}
#+END_SRC
*** DONE Freeing
CLOSED: [2019-09-12 Thu 08:27]
Freed with =worgle_orgfile_free=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orgfile_free(worgle_orgfile *org);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_free(worgle_orgfile *org)
{
    worgle_orglet *ent;
    worgle_orglet *nxt;
    int n;
    if (org->size > 0) {
        ent = org->head;
        for (n = 0; n < org->size; n++) {
            nxt = ent->next;
            worgle_orglet_free(ent);
            ent = nxt;
        }
    }
}
#+END_SRC
*** Appending To File
Operations to append things to files.
**** Appending an orglet
This operation applies a general orglet to a
=worgle_orgfile=. This orglet should be initialized and
allocated by this point.

Most of the time, this is called indirectly through
other functions.
#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_orgfile_append(worgle_d *worg,
                           worgle_orgfile *file,
                           worgle_orglet *orglet);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_append(worgle_d *worg,
                           worgle_orgfile *file,
                           worgle_orglet *orglet)
{
    if (file->size <= 0) {
        file->head = orglet;
        file->tail = orglet;
    }

    file->tail->next = orglet;
    file->tail = orglet;
    file->size++;
    <<worgle_orglet_set_id>>
}
#+END_SRC
**** DONE Appending a header
CLOSED: [2019-09-12 Thu 08:27]
Appends a header to file.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orgfile_append_header(worgle_d *worg,
                                  worgle_string *header,
                                  int lvl);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_append_header(worgle_d *worg,
                                  worgle_string *header,
                                  int lvl)
{
    worgle_orglet *orglet;
    worgle_orglet_header *h;
    worgle_orgfile *f;
    size_t linum;

    f = worg->curorg;
    linum = worg->linum;

    orglet = calloc(1, sizeof(worgle_orglet));
    h = calloc(1, sizeof(worgle_orglet_header));

    h->str = *header;
    h->lvl = lvl;
    worgle_orglet_init(orglet);

    orglet->type = ORGLET_HEADER;
    orglet->ud = h;
    orglet->linum = linum;
    worgle_orgfile_append(worg, f, orglet);
}
#+END_SRC
**** TODO Appending Content
Appends content block to an org file.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orgfile_append_content(worgle_d *worg,
                                   worgle_string *text);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_append_content(worgle_d *worg,
                                   worgle_string *text)
{
    worgle_orglet *orglet;
    worgle_orglet_content *c;
    worgle_orgfile *f;
    size_t linum;

    f = worg->curorg;
    linum = worg->linum;

    orglet = calloc(1, sizeof(worgle_orglet));
    c = calloc(1, sizeof(worgle_orglet_content));

    c->text = *text;
    worgle_orglet_init(orglet);

    orglet->type = ORGLET_CONTENT;
    orglet->ud = c;
    orglet->linum = linum;
    worgle_orgfile_append(worg, f, orglet);
}
#+END_SRC
**** TODO Appending Block Reference
Appends a reference to a code block. Should be called when
a block first starts.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orgfile_append_reference(worgle_d *worg,
                                     worgle_block *blk);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orgfile_append_reference(worgle_d *worg,
                                     worgle_block *blk)
{
    worgle_orglet *orglet;
    worgle_orglet_blkref *br;
    worgle_orgfile *f;
    size_t linum;

    f = worg->curorg;
    linum = worg->linum;

    orglet = calloc(1, sizeof(worgle_orglet));
    br = calloc(1, sizeof(worgle_orglet_blkref));

    br->blk = blk;
    worgle_orglet_init(orglet);

    orglet->type = ORGLET_CONTENT;
    orglet->ud = br;
    orglet->linum = linum;
    worgle_orgfile_append(worg, f, orglet);
}
#+END_SRC
** DONE Orglet
CLOSED: [2019-09-11 Wed 04:55]
A =worgle_orglet= is a single entry inside of a
=worgle_orgfile=.
*** Struct
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_orglet worgle_orglet;
#+END_SRC
#+NAME: worgle_orglet
#+BEGIN_SRC c
<<worgle_orglet_subtypes>>
struct worgle_orglet {
    int type;
    void *ud;
    worgle_orglet *next;
    size_t linum;
    <<worgle_orglet_id>>
};
#+END_SRC
*** Initializing
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orglet_init(worgle_orglet *orglet);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orglet_init(worgle_orglet *orglet)
{
    orglet->type = ORGLET_UNKNOWN;
    orglet->ud = NULL;
    orglet->next = NULL;
    orglet->linum = 0;
    <<worgle_orglet_id_init>>
}
#+END_SRC
*** Freeing
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_orglet_free(worgle_orglet *orglet);
#+END_SRC
#+NAME: functions
#+BEGIN_SRC c
void worgle_orglet_free(worgle_orglet *orglet)
{
    free(orglet->ud);
    free(orglet);
}
#+END_SRC
*** Types
populated here
#+NAME: enums
#+BEGIN_SRC c
enum {
<<orglet_types>>
ORGLET_UNKNOWN
};
#+END_SRC
*** DONE Orglet Header
CLOSED: [2019-09-11 Wed 04:55]
#+NAME: orglet_types
#+BEGIN_SRC c
ORGLET_HEADER,
#+END_SRC
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_orglet_header worgle_orglet_header;
#+END_SRC
#+NAME: worgle_orglet_subtypes
#+BEGIN_SRC c
struct worgle_orglet_header {
    worgle_string str;
    int lvl;
};
#+END_SRC
*** TODO Orglet Content
#+NAME: orglet_types
#+BEGIN_SRC c
ORGLET_CONTENT,
#+END_SRC
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_orglet_content worgle_orglet_content;
#+END_SRC
#+NAME: worgle_orglet_subtypes
#+BEGIN_SRC c
struct worgle_orglet_content {
    worgle_string text;
};
#+END_SRC
*** TODO Orglet Block Reference
#+NAME: orglet_types
#+BEGIN_SRC c
ORGLET_BLKREF,
#+END_SRC
#+NAME: typedefs
#+BEGIN_SRC c
typedef struct worgle_orglet_blkref worgle_orglet_blkref;
#+END_SRC
#+NAME: worgle_orglet_subtypes
#+BEGIN_SRC c
struct worgle_orglet_blkref {
    worgle_block *blk;
};
#+END_SRC
* Command Line Arguments
This section outlines command line arguments in Worgle.
** Parsing command line flags

Command line argument parsing is done using the third-party library
[[https://github.com/jibsen/parg][parg]], included in this source distribution.

#+NAME: local_variables
#+BEGIN_SRC c
struct parg_state ps;
int c;
#+END_SRC

#+NAME: parse_cli_args
#+BEGIN_SRC c
parg_init(&ps);
while ((c = parg_getopt(&ps, argc, argv, "gW:m:d:p:n")) != -1) {
    switch(c) {
        case 1:
            filename = (char *)ps.optarg;
            <<append_filename>>
            break;
        case 'g':
            <<turn_on_debug_macros>>
            break;
        case 'W':
            <<turn_on_warnings>>
            break;
        case 'm':
            <<map_source_code>>
            break;
        case 'd':
#ifndef WORGLITE
            <<generate_database>>
#else
            fprintf(stderr, "Database flag (-d) is  not enabled\n");
            return 1;
#endif
            break;
        case 'p':
            <<set_program_id>>
            break;
        case 'n':
            <<disable_tangling>>
            break;
        default:
            fprintf(stderr, "Unknown option -%c\n", c);
            return 1;
    }
}
#+END_SRC

** Turning on debug macros (-g)

Worgle has the ability to generate debug macros when generating C files.

This will turn on a boolean flag called =use_debug= inside the worgle struct.

#+NAME: turn_on_debug_macros
#+BEGIN_SRC c
use_debug = 1;
#+END_SRC

By default, =use_debug= is set to be false in order to allow other non-C
languages to be used.

#+NAME:global_variables
#+BEGIN_SRC c
static int use_debug = 0;
#+END_SRC

** Turning on Warnings (-W)

Worgle can print out warnings about things like unused
sections of code. By default, this is turned off.

#+NAME:global_variables
#+BEGIN_SRC c
static int use_warnings = 0;
#+END_SRC

#+NAME: turn_on_warnings
#+BEGIN_SRC c
if(!strncmp(ps.optarg, "soft", 4)) {
    use_warnings = 1;
} else if(!strncmp(ps.optarg, "error", 5)) {
    use_warnings = 2;
} else {
    fprintf(stderr, "Unidentified warning mode '%s'\n", ps.optarg);
    return 1;
}
#+END_SRC

*** Checking for unused blocks
One thing that warnings can do is check for unused blocks.
This is done after the files are generated with the function
=worgle_warn_unused=.

#+NAME:function_declarations
#+BEGIN_SRC c
int worgle_warn_unused(worgle_d *worg);
#+END_SRC

#+NAME:functions
#+BEGIN_SRC c
int worgle_warn_unused(worgle_d *worg)
{
    worgle_hashmap *dict;
    worgle_block *blk;
    worgle_blocklist *lst;
    int n;
    int b;
    int rc;

    dict = &worg->dict;
    rc = 0;

    for(n = 0; n < HASH_SIZE; n++) {
        lst = &dict->blk[n];
        blk = lst->head;
        for(b = 0; b < lst->nblocks; b++) {
            if(blk->am_i_used == 0) {
                fprintf(stderr, "Warning: block '");
                worgle_string_write(stderr, &blk->name);
                fprintf(stderr, "' unused.\n");
                fprintf(stderr, "First declared in ");
                worgle_string_write(stderr,
                                    blk->head->filename);
                fprintf(stderr, ", line %lu\n",
                        blk->head->linum);
                if(use_warnings == 2) rc = 1;
            }
            blk = blk->nxt;
        }
    }
    return rc;
}
#+END_SRC
** Map Source Code (-m)
This flag will turn on source code mappings. It will dump the source code map
to a specified file. The filename is stored in a global variable.

#+NAME:global_variables
#+BEGIN_SRC c
static int map_source_code = 0;
static char *map_filename = NULL;
#+END_SRC

#+NAME: map_source_code
#+BEGIN_SRC c
map_source_code = 1;
map_filename = (char *)ps.optarg;
#+END_SRC
** Appending filenames
#+NAME: append_filename
#+BEGIN_SRC c
append_filename(&worg, (char *)ps.optarg);
#+END_SRC

#+NAME: static_function_declarations
#+BEGIN_SRC c
static void append_filename(worgle_d *worg, char *filename);
#+END_SRC

For now, just append the file name to the first item on the
list.
#+NAME: functions
#+BEGIN_SRC c
static void append_filename(worgle_d *worg, char *filename)
{
    worgle_string *str;
    int pos;
    pos = worg->nbuffers;
    worg->nbuffers++;
    if(worg->nbuffers == 1) {
        worg->buffers = calloc(1, sizeof(worgle_textbuf));
    } else {
        worg->buffers = realloc(worg->buffers,
                                sizeof(worgle_textbuf) *
                                worg->nbuffers);
    }
    str = &worg->buffers[pos].filename;
    str->str = filename;
    str->size = strlen(filename);
#ifndef WORGLITE
    <<append_org_file>>
#endif
}
#+END_SRC
** Generate Database (-d)
This flag will turn on database generation, assuming that it
is enabled.

#+NAME:global_variables
#+BEGIN_SRC c
#ifndef WORGLITE
static int generate_db = 0;
static char *db_filename = NULL;
#endif
#+END_SRC

#+NAME: generate_database
#+BEGIN_SRC c
generate_db = 1;
db_filename = (char *)ps.optarg;
#+END_SRC

#+NAME: static_function_declarations
#+BEGIN_SRC c
#ifndef WORGLITE
static void tangle_to_db(worgle_d *worg);
#endif
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
#ifndef WORGLITE
static void tangle_to_db(worgle_d *worg)
{
    sqlite3 *db;
    int rc;

    if(db_filename == NULL) return;

    rc = sqlite3_open(db_filename, &db);
    if(rc) {
        fprintf(stderr,
                "Could not open database: %s",
                sqlite3_errmsg(db));
        sqlite3_close(db);
        return;
    }
    worgle_db_clear(db, worg->prog);
    worgle_db_schemas(worg, db);
    worgle_db_generate(worg, db);
    sqlite3_close(db);
}
#endif
#+END_SRC

#+NAME:database
#+BEGIN_SRC c
#ifndef WORGLITE
if(generate_db) tangle_to_db(&worg);
#endif
#+END_SRC
** Set program id (-p)
The p flag is used to set the program ID, which is
then written to the database.
#+NAME: set_program_id
#+BEGIN_SRC c
worg.prog = atoi(ps.optarg);
#+END_SRC
** Disable tangling (-n)
This flag will disable any tangling. This is useful
with the =-d= flag for only generating the SQLite database.

#+NAME: global_variables
#+BEGIN_SRC c
static int tangle_code = 1;
#+END_SRC
#+NAME: disable_tangling
#+BEGIN_SRC c
tangle_code = 0;
#+END_SRC
* Source mapping
Worgle has the ability to produce Org data that outlines the structure
of the named blocks.

#+NAME: mapping
#+BEGIN_SRC c
if(map_source_code && map_filename != NULL) {
    worgle_map_files(&worg, map_filename);
}
#+END_SRC

The idea behind this functionality is to provide
a quick overview of the source code structure from the blocks
perspective, rather than from the text perspective.

Every file has a top level block, which is recursively iterated through.

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_map(worgle_d *worg, worgle_block *b, int lvl, FILE *out);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_map(worgle_d *worg, worgle_block *b, int lvl, FILE *out)
{
    int i;
    worgle_segment *s;
    worgle_block *newblk;
    worgle_hashmap *h;

    h = &worg->dict;
    if(lvl != 0) {
        for(i = 0; i <= lvl; i++) {
            fputc('*', out);
        }
        fputc(' ', out);
        worgle_string_write(out, &b->name);
        fputc('\n', out);
    }

    s = b->head;

    newblk = NULL;

    for(i = 0; i < b->nsegs; i++) {
        if(s->type == SEGTYPE_TEXT) {
            if(s->str.size > 0) {
                worgle_string_write(out, s->filename);
                fprintf(out, ":%lu\n", s->linum);
                fprintf(out, "#+NAME: ");
                worgle_string_write(out, &b->name);
                fprintf(out, "_%d\n", i);
                fprintf(out, "#+BEGIN_SRC\n");
                worgle_string_write(out, &s->str);
                fprintf(out, "#+END_SRC");
            }
            fprintf(out, "\n");
        } else if(worgle_hashmap_find(h, &s->str, &newblk)) {
            worgle_map(worg, newblk, lvl + 1, out);
        }
        s = s->nxt;
    }
}
#+END_SRC

#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_map_files(worgle_d *worg, char *filename);
void worgle_map_a_file(worgle_d *worg, worgle_file *file, FILE *out);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_map_files(worgle_d *worg, char *filename)
{
    int n;
    worgle_file *f;
    FILE *fp;

    fp = fopen(filename, "w");
    if(fp == NULL) return;

    f = worg->flist.head;

    fprintf(fp, "#+TITLE: Code Map\n");
    for(n = 0; n < worg->flist.nfiles; n++) {
        worgle_map_a_file(worg, f, fp);
        f = f->nxt;
    }

    fclose(fp);
}

void worgle_map_a_file(worgle_d *worg, worgle_file *file, FILE *out)
{
    fprintf(out, "* ");
    worgle_string_write(out, &file->filename);
    fprintf(out, "\n");
    worgle_map(worg, file->top, 0, out);
}
#+END_SRC
