#+TITLE: Worgle Database
* Worgle Database (WIP)
This section outlines the portion of Worgle which handles database
export. At the time of writing, this feature does not exist yet.
The main idea behind this is to be able to take a program Org, and
export all the metadata into a SQLite database. In the future, other
programs will be written to query the generated database and dynamically
display portions of the program in interesting ways.

Instead of using the SQLite API to generate the database directly, the Worgle
database interface will write SQL INSERT statements to be read by the sqlite3
command line interface.
** Worgle Database Top
*** Top-level files
The worgle database interface generates a single C and header file.

# functions and function_declarations correspond to the main worgle.org file

#+NAME: db-top
#+BEGIN_SRC c :tangle db.c
#include <stdio.h>
#include "worgle.h"
#include "worgle_private.h"
#include "db.h"
<<macros>>
<<functions>>
#+END_SRC
#+NAME: db-header
#+BEGIN_SRC c :tangle db.h
#ifndef WORGLE_DB_H
#define WORGLE_DB_H
<<function_declarations>>
#endif
#+END_SRC
*** Top-level function
The SQLite database generation is done with the function =worgle_db_generate=.
It will write SQLite commands to a file handle =fp=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_db_generate(worgle_d *worg, FILE *fp);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_db_generate(worgle_d *worg, FILE *fp)
{
    <<schemas>>
    <<inserts>>
}
#+END_SRC
** SQLite Table Schemas
The following section describes the SQLite schemas for all the tables
needed by Worgle.
*** Segment Schema
The segment schema contains the following items:

- the UUID
- the type (stored as integer)
- the line number
- the file (filename, not UUID) that it belongs to
- the UUID of the next segment

The types for segments are defined in an ENUM.

#+NAME: macros
#+BEGIN_SRC c
enum {
    SEGMENT_STRING,
    SEGMENT_REFERENCE
};
#+END_SRC

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE segments(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "type INTEGER,\n");
fprintf(fp, "str INTEGER,\n");
fprintf(fp, "linum INTEGER,\n");
fprintf(fp, "filename TEXT,\n");
fprintf(fp, "next_segment INTEGER\n");
fprintf(fp, ");\n");
#+END_SRC
*** Block Schema
The block schema contains the following items:

- the UUID
- the UUID of the segment head
- the name of the block
- the UUID of the next block

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE block(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "head_segment INTEGER,\n");
fprintf(fp, "name TEXT,\n");
fprintf(fp, "next_block INTEGER\n");
fprintf(fp, ");\n");
#+END_SRC
*** File Schema
A file name table contains the following:

- UUID
- filename
- the top-level block
- the UUID for the next file (0 if there is no next file)

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE file(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "filename TEXT,\n");
fprintf(fp, "type INTEGER,\n");
fprintf(fp, "next_file INTEGER\n");
fprintf(fp, ");\n");
#+END_SRC
*** UUID Schema
Every single UUID is logged into a single table. This table has every single
UUID and their type.

- UUID
- type (as an integer)

The integer-based types are defined as enums below:

#+NAME: macros
#+BEGIN_SRC c
enum {
    RES_FILE,
    RES_BLOCK,
    RES_SEGMENT
};
#+END_SRC

#+NAME: schemas
#+BEGIN_SRC c
fprintf(fp, "CREATE TABLE resources(\n");
fprintf(fp, "id INTEGER PRIMARY KEY,\n");
fprintf(fp, "type INTEGER\n");
fprintf(fp, ");\n");
#+END_SRC
** SQLite Insert Statements
This section pertains to the actual SQLite insert statements that occur.
Generally speaking, data in Worgle can be broken up into two perspectives:
tangled data (the generated code for the compiler), and
woven data (the markup and semantics).
*** SQLite Tangled Data
The way Worgle generates data is by recursively iterating through the file list.
The SQLite table will be populated in the same way.
**** Top-level tangle insert
Table population tangle insert is done inside the function =worgle_db_generate=.

#+NAME: inserts
#+BEGIN_SRC c
worgle_db_insert_filelist(worg, &worg->flist, fp);
#+END_SRC
**** Filelist Insert
The top-level part of the code walks through the file list inside of
=worgle_db_insert_filelist=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_db_insert_filelist(worgle_d *worg, worgle_filelist *flist, FILE *fp);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_db_insert_filelist(worgle_d *worg, worgle_filelist *flist, FILE *fp)
{
    worgle_file *f;
    int n;

    f = flist->head;
    for(n = 0; n < flist->nfiles; n++) {
        worgle_db_insert_file(worg, f, fp);
        f = f->nxt;
    }
}
#+END_SRC
**** File Insert
A file is inserted with the function =worgle_db_insert_file=.
#+NAME: function_declarations
#+BEGIN_SRC c
void worgle_db_insert_file(worgle_d *worg, worgle_file *file, FILE *fp);
#+END_SRC

#+NAME: functions
#+BEGIN_SRC c
void worgle_db_insert_file(worgle_d *worg, worgle_file *file, FILE *fp)
{
    worgle_long next_id;

    if(file->nxt == NULL) next_id = 0;
    else next_id = file->nxt->id;
    fprintf(fp, "INSERT INTO file(id, next_file, filename)\n");
    fprintf(fp, "VALUES(%lu, %lu, ",
            file->id,
            next_id);
    fprintf(fp, "\"");
    worgle_string_write(fp, &file->filename);
    fprintf(fp, "\");\n");
    worgle_db_insert_block(worg, file->top, fp);
}
#+END_SRC
**** Block Insert
A block is inserted with the function =worgle_db_insert_block=.
#+NAME:function_declarations
#+BEGIN_SRC c
void worgle_db_insert_block(worgle_d *worg, worgle_block *block, FILE *fp);
#+END_SRC

#+NAME:functions
#+BEGIN_SRC c
void worgle_db_insert_block(worgle_d *worg, worgle_block *block, FILE *fp)
{
    worgle_segment *s;
    int n;
    worgle_long next_segment;
    int new_insert;
    worgle_block *blk;
    worgle_hashmap *hm;
    s = block->head;
    hm = &worg->dict;
    fprintf(fp, "INSERT INTO block(id, head_segment, next_block, name)\n");
    fprintf(fp, "VALUES(%lu, %lu, %lu, ",
            block->id,
            block->head->id,
            block->nxt->id);
    fprintf(fp, "\"");
    worgle_string_write(fp, &block->name);
    fprintf(fp, "\");\n");
    new_insert = 1;
    for(n = 0; n < block->nsegs; n++) {
        if(new_insert) {
            new_insert = 0;
            fprintf(fp, "INSERT INTO segments");
            fprintf(fp, "(id, type, linum, next_segment, str) VALUES\n");
        }
        if(s->nxt != NULL) next_segment = s->nxt->id;
        else next_segment = 0;
        fprintf(fp, "(%lu, %d, %lu, %lu, ",
                s->id,
                s->type,
                s->linum,
                next_segment);
        fprintf(fp, "\"");
        worgle_string_write(fp, &s->str);
        if(worgle_segment_is_reference(s)) {
            if(!worgle_hashmap_find(hm, &s->str, &blk)) break;
            fprintf(fp, "\");\n");
            worgle_db_insert_block(worg, blk, fp);
            new_insert = 1;
        }
        if(n == block->nsegs - 1) {
            fprintf(fp, "\");\n");
        } else {
            fprintf(fp, "\"),\n");
        }
        s = s->nxt;
    }
}
#+END_SRC
